import { $Values as Values } from 'utility-types';
import { Distance, Pixels, Radian, Radius, Ratio, SizeRatio, TimeMs } from '../../../../common/geometry';
import { Font, FontFamily, PartialFont, TextContrast } from '../../../../common/text_utils';
import { Color, StrokeStyle, ValueFormatter } from '../../../../utils/common';
import { PerSideDistance } from '../../../../utils/dimensions';
/** @public */
export declare const PartitionLayout: Readonly<{
    sunburst: "sunburst";
    treemap: "treemap";
    icicle: "icicle";
    flame: "flame";
    mosaic: "mosaic";
    waffle: "waffle";
}>;
/** @public */
export declare type PartitionLayout = Values<typeof PartitionLayout>;
/** @public */
export declare type PerSidePadding = PerSideDistance;
/** @public */
export declare type Padding = Pixels | Partial<PerSidePadding>;
interface LabelConfig extends Font {
    textColor: Color;
    textInvertible: boolean;
    textContrast: TextContrast;
    textOpacity: Ratio;
    valueFormatter: ValueFormatter;
    valueFont: PartialFont;
    padding: Padding;
}
/** @public */
export interface FillLabelConfig extends LabelConfig {
    clipText: boolean;
}
/** @public */
export interface LinkLabelConfig extends LabelConfig {
    fontSize: Pixels;
    maximumSection: Distance;
    gap: Pixels;
    spacing: Pixels;
    minimumStemLength: Distance;
    stemAngle: Radian;
    horizontalStemLength: Distance;
    radiusPadding: Distance;
    lineWidth: Pixels;
    maxCount: number;
    maxTextLength: number;
}
/** @public */
export interface FillFontSizeRange {
    minFontSize: Pixels;
    maxFontSize: Pixels;
    idealFontSizeJump: Ratio;
    /**
     * When `maximizeFontSize` is false (the default), text font will not be larger than font sizes in larger sectors/rectangles in the same pie chart,
     * sunburst ring or treemap layer. When it is set to true, the largest font, not exceeding `maxFontSize`, that fits in the slice/sector/rectangle
     * will be chosen for easier text readability, irrespective of the value.
     */
    maximizeFontSize: boolean;
}
/** @public */
export interface RelativeMargins {
    left: SizeRatio;
    right: SizeRatio;
    top: SizeRatio;
    bottom: SizeRatio;
}
/** @public */
export interface StaticConfig extends FillFontSizeRange {
    width: number;
    height: number;
    margin: RelativeMargins;
    emptySizeRatio: SizeRatio;
    outerSizeRatio: SizeRatio;
    clockwiseSectors: boolean;
    specialFirstInnermostSector: boolean;
    partitionLayout: PartitionLayout;
    /** @alpha */
    drilldown: boolean;
    fontFamily: FontFamily;
    circlePadding: Distance;
    radialPadding: Distance;
    horizontalTextAngleThreshold: Radian;
    horizontalTextEnforcer: Ratio;
    maxRowCount: number;
    fillOutside: boolean;
    radiusOutside: Radius;
    fillRectangleWidth: Distance;
    fillRectangleHeight: Distance;
    fillLabel: FillLabelConfig;
    linkLabel: LinkLabelConfig;
    backgroundColor: Color;
    sectorLineWidth: Pixels;
    sectorLineStroke: StrokeStyle;
}
/** @alpha */
export declare type EasingFunction = (x: Ratio) => Ratio;
/** @alpha */
export interface AnimKeyframe {
    time: number;
    easingFunction: EasingFunction;
    keyframeConfig: Partial<StaticConfig>;
}
/** @public */
export interface Config extends StaticConfig {
    /** @alpha */
    animation: {
        duration: TimeMs;
        keyframes: Array<AnimKeyframe>;
    };
}
export {};
//# sourceMappingURL=config_types.d.ts.map